from pyforest.actions import AbstractAction
from pyforest.actions import EachStepRunnerMixin
from pyforest.utils.randomizer import nrandom, irand

import numpy as np


class UniformDisperseTreeAction(EachStepRunnerMixin):

    '''
    Simulates seeds spreading for the specified tree species

    :param intensity: average number of seeds to be added to model;
    :param distribution: type of distribution to be used for seed
                          placing (assigning of its coordinates);
                          Default is Poisson distribution.
    :param species: tree species
    :type intensity: int
    :type distribution: string
    :type species: string

    **How it works**

    Tree positions don't accounted. No matter
    tree species are presented in the model or not, this action
    just appends seeds of specified species to the array
    of seeds in the model.

    {0}
    '''.format(EachStepRunnerMixin.__activation_conds__)

    def __init__(self, distribution='poisson', *args, **kwargs):
        super(UniformDisperseTreeAction, self).__init__(*args, **kwargs)
        self.intensity = kwargs['intensity']
        self.distribution = distribution
        self.species = kwargs['species']

    def process(self):
        #: TODO Extra distribution models should be added here!
        size = self.intensity
        if self.distribution == 'poisson':
            size = np.random.poisson(size)
        xdata = irand(*self.model.bbox[0], size=size)
        ydata = irand(*self.model.bbox[1], size=size)
        tdata = np.array([self.model.step]*size)
        if self.species in self.model.seeds:
            xdata = np.append(self.model.seeds[self.species][0], xdata)
            ydata = np.append(self.model.seeds[self.species][1], ydata)
            tdata = np.append(self.model.seeds[self.species][2], tdata)
        self.model.seeds.update({self.species: np.array([xdata,
                                                         ydata, tdata])})


class UniformDisperseConstrainedAction(UniformDisperseTreeAction):
    '''
    Simulates seeds spreading for the specified tree species

    It is applied once at the each step of modeling.

    **Parameters**

    :param intensity: average number of seeds to be appended to the model;
    :param distribution: type of distribution to be used for assignment
                        places for seeds;
    :param species: tree species
    :type intensity: int
    :type distribution: string
    :type species: string

    **How it works**

    Seeds placed to empty places only, taking into
    account current distribution of objects (i.e. trees, shrubs)
    in the model.

    {0}
    '''.format(UniformDisperseTreeAction.__activation_conds__)

    def __init__(self, *args, **kwargs):
        super(UniformDisperseConstrainedAction, self).__init__(*args, **kwargs)
        self.intensity = kwargs['intensity']
        self.distribution = kwargs['distribution']
        self.species = kwargs['species']

    def process(self):
        #: TODO Extra distribution models should be added here!
        size = self.intensity
        if self.distribution == 'poisson':
            size = np.random.poisson(size)
        xdata = irand(*self.model.bbox[0], size=size)
        ydata = irand(*self.model.bbox[1], size=size)
        tdata = np.array([self.model.step]*size)
        for k in range(len(xdata)):
            # TODO: seeds should be randomly moved if
            # they created where a tree exist
            pass
        if self.species in self.model.seeds:
            xdata = np.append(self.model.seeds[self.species][0], xdata)
            ydata = np.append(self.model.seeds[self.species][1], ydata)
            tdata = np.append(self.model.seeds[self.species][2], tdata)
        self.model.seeds.update({self.species: np.array([xdata,
                                                         ydata, tdata])})


class RadialDecayTreeSeedingAction(EachStepRunnerMixin):
    r'''
    Generates tree seeds taking into account species-specific
    seeding intensity and a tree size

    **How it works**

    It uses the following species-specific parameters to calculate
    seeding intensity of a tree (it depends on a tree :code:`dbh` parameter):

        * `MAX_INTENSITY_SEEDING_R_DECAY`, `INTENSITY_SLOPE_SEEDING_R_DECAY`
          `INTENSITY_SHIFT_SEEDING_R_DECAY` -- these all used to get the number
          of seeds generated by a tree (Verhulst's law is used). If we denote
          :math:`a` =  `MAX_INTENSITY_SEEDING_R_DECAY`, :math:`b` =
          `INTENSITY_SLOPE_SEEDING_R_DECAY` and :math:`c` =
          `INTENSITY_SHIFT_SEEDING_R_DECAY`, the formula used to compute
          a tree seeding intensity will be as follows

          .. math::

              intensity = 1 + [\frac{{a}}{{1 + \exp^{{-b * (dbh - c)}}}}],

          where `dbh` -- a tree dbh parameter and :math:`[\cdot]` -- rounding
          operator.

        * `H_MAX_DIST_SEEDING_R_DECAY`, `K_HEIGHT_IMPACT_SEEDING_R_DECAY`,
          `H0_HEIGHT_DIST_SEEDING_R_DECAY` are used to model how far from
          the parent tree seeds could fall.
          If :math:`r` is distance from a parent tree, and :math:`r_m` some
          extra parameter (that will be described below), the following
          distribution law (cdf-function) is used:

          .. math::

              \begin{{array}}{{l}}
              P(\xi < r) = 1-\frac{{(r_m-r)^2}}{{r_m^2}}, if  0\leq r\leq r_m,\\
              P(\xi < r) = 0, if r < 0, \\
              P(\xi < r) = 1, if r > r_m.
              \end{{array}}

          In this case :math:`r_m` species-specific argument that means
          maximal distance from place where a seed fall to the parent tree.
          Obviously, it should depend on a tree height, so, Verhulst's law
          to calculate :math:`r_m` too (with the same formula as above and the
          order of short definitions of variables), i.e.
          `H_MAX_DIST_SEEDING_R_DECAY` = a, ... etc.

    {0}
    '''.format(EachStepRunnerMixin.__activation_conds__)

    def __init__(self, *args, **kwargs):
        self._required_parameters = ('MAX_INTENSITY_SEEDING_R_DECAY',
                                     'INTENSITY_SLOPE_SEEDING_R_DECAY',
                                     'INTENSITY_SHIFT_SEEDING_R_DECAY',
                                     'H_MAX_DIST_SEEDING_R_DECAY',
                                     'K_HEIGHT_IMPACT_SEEDING_R_DECAY',
                                     'H0_HEIGHT_DIST_SEEDING_R_DECAY')
        super(RadialDecayTreeSeedingAction, self).__init__(*args, **kwargs)

    def process(self):
        for item in self.model.objects.select_by_type('tree').select_by_stages(['sapling', 'adult']):
            tochose = self._parameters.get(item.species, self._parameters['none'])
            ld = tochose.get('MAX_INTENSITY_SEEDING_R_DECAY',
                             self._parameters['none']['MAX_INTENSITY_SEEDING_R_DECAY'])
            kd = tochose.get('INTENSITY_SLOPE_SEEDING_R_DECAY',
                             self._parameters['none']['INTENSITY_SLOPE_SEEDING_R_DECAY'])
            d0 = tochose.get('INTENSITY_SHIFT_SEEDING_R_DECAY',
                             self._parameters['none']['INTENSITY_SHIFT_SEEDING_R_DECAY'])
            lh = tochose.get('H_MAX_DIST_SEEDING_R_DECAY',
                             self._parameters['none']['H_MAX_DIST_SEEDING_R_DECAY'])
            kh = tochose.get('K_HEIGHT_IMPACT_SEEDING_R_DECAY',
                             self._parameters['none']['K_HEIGHT_IMPACT_SEEDING_R_DECAY'])
            h0 = tochose.get('H0_HEIGHT_DIST_SEEDING_R_DECAY',
                             self._parameters['none']['H0_HEIGHT_DIST_SEEDING_R_DECAY'])
            r_m = lh / (1 + np.exp(-kh * (item.height - h0)))
            intensity = nrandom.poisson(1 + int(ld / (1 +
                                                      np.exp(-kd *
                                                             (item.dbh - d0))))
                                        )
            uniforms = nrandom.uniform(size=intensity)
            r_distrib = r_m - np.sqrt(1.0 - uniforms) * r_m
            rand_rots = nrandom.uniform(size=intensity) * 2.0 * np.pi
            xdata = item.x + r_distrib * np.cos(rand_rots)
            ydata = item.y + r_distrib * np.sin(rand_rots)
            tdata = np.array([self.model.step]*intensity)
            if item.species in self.model.seeds:
                xdata = np.append(self.model.seeds[item.species][0], xdata)
                ydata = np.append(self.model.seeds[item.species][1], ydata)
                tdata = np.append(self.model.seeds[item.species][2], tdata)
            self.model.seeds.update({item.species: np.array([xdata,
                                                             ydata, tdata])})


class NormalDecayTreeSeedingAction(EachStepRunnerMixin):
    '''# TODO: Implement it
    '''
    def __init__(self, *args, **kwargs):
        super(NormalDecayTreeSeedingAction, self).__init__(*args, **kwargs)


class EmptyPlaceSeedsMoverAction(EachStepRunnerMixin):
    '''# TODO: Implement it
    Move seeds that fall to non-empty place
    **How it works**
    *Dependencies*

    '''
    def process(self):
        pass
